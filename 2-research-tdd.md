---
description: "Спроектировать решение задачи через призму TDD"
---

## Контекст работы

Вы работаете в human-in-the-loop процессе внесения изменений в кодовую базу проекта, с соблюдением лучших практик SDLC и TDD.
Вы находитесь на этапе **проектирования высокоуровневой архитектуры технического решения**, где ваша цель — создать не просто план кодирования, а **комплексный план верификации** решения через тесты.

## Ваша цель

Создать **дизайн-документ, ориентированный на поведение и тесты**. Критерии приёмки из `task_definition.md` должны быть трансформированы в четкий, исполняемый план тестирования.

Цель — гарантировать, что решение будет полным, проверяемым и соответствовало требованиям ДО начала реализации.

## Процесс

### 0. Инициализация и контекст

1.  **Прочтите исходные данные:**
    *   Изучите `.context/README.md` для понимания общего контекста проекта
    *   Изучите `.context/tips/INDEX.md` для понимания явно определённых примеров реализаций "ЕСЛИ X, используй Y"
    *   Изучите `task_definition.md` (фокус на **Критериях приёмки**).
    *   Изучите `research.md` (фокус на **архитектурных ограничениях и возможностях**).
    *   При отсутствии файлов запросите их через `ask_followup_question`.

### 1. Создание дизайн-дока в стиле TDD

1.  **Создайте файл дизайна:** `.context/tasks/<task_name>/solution_design.md`.
2.  **Выберите специализацию:** Используйте шаблон из раздела "Специализации", основанный на типе задачи.
3.  **Начните с тестов:** Первым разделом дизайн-дока должен быть **"План тестирования и критерии верификации"**.

### 2. Инкрементальный дизайн через цикл TDD (Основной цикл)

**Повторяйте этот цикл для каждой новой поведенческой единицы (фичи), выявленной в задаче:**

**A. Красная фаза (Определение ожидаемого поведения):**
*   На основе критериев приёмки и анализа кода сформулируйте **одно конкретное ожидаемое поведение** системы.
*   **Сформулируйте это поведение как тест-кейс.** Опишите:
    *   **Сценарий:** Краткое название того, что проверяем (e.g., "Успешное создание элемента при валидных данных").
    *   **Данные/Действие:** Какие данные подаются на вход или какое действие выполняется.
    *   **Ожидаемый результат:** Что должна вернуть система или в какое состояние перейти.
*   **Спросите себя:** "Если бы я запустил идеальный тест для этого поведения, что бы он проверял?".
*   Если не хватает информации для формулировки теста, задайте уточняющий вопрос через `ask_followup_question`.

**B. Зеленая фаза (Проектирование реализации):**
*   **На высоком уровне опишите, КАК система будет достигать поведения из фазы A.**
*   **Сфокусируйтесь на интерфейсах, контрактах и взаимодействиях, а не на коде:**
    *   *Вместо:* "Создадим функцию `X` с циклом `for`"...
    *   *Напишите:* "Модуль `А` предоставит метод `Y`, который принимает структуру `Z` и возвращает `Promise<Result>`. Этим займётся сервис `B`."
*   **Сверьтесь с research.md:** Ваше предложение должно использовать существующие архитектурные паттерны и соглашения кодовой базы.
*   Зафиксируйте это решение в соответствующем разделе дизайн-дока.

**C. Фаза рефакторинга (Анализ архитектурного влияния):**
*   **Проанализируйте предложенное решение на предмет:**
    *   **Совместимости:** Не сломает ли это изменение существующие функции? Сверьтесь со списком зависимостей из `research.md`.
    *   **Масштабируемости:** Соответствует ли предложенное решение долгосрочной архитектуре проекта?
    *   **Чистоты дизайна:** Можно ли эту задачу решить более простым или унифицированным с кодобазой способом?
*   Если анализ выявляет проблемы, вернитесь к фазе **B** и пересмотрите дизайн.

### 3. Финальная верификация дизайна

1.  **Проверка полноты:** Убедитесь, что для каждого критерия приёмки из `task_definition.md` есть как минимум один тест-кейс в дизайн-доке.
2.  **Проверка тестируемости:** Спросите себя: "Достаточно ли описанных тест-кейсов, чтобы разработчик понял, что именно тестировать и как проверить результат?".
3.  **Запрос фидбека:** Предоставьте пользователю краткое резюме: "Я предложил дизайн, который покрывает N требований через X тест-кейсов. Основной подход: [Высокоуровневое описание подхода]".
4.  **Финальное утверждение:** Попросите пользователя утвердить дизайн-док через `ask_followup_question`.

## Специализации дизайн-документа (TDD-ориентированные)

### СПЕЦИАЛИЗАЦИЯ: ДИЗАЙН FRONTEND-ФИЧИ

```
# Дизайн решения: [Название задачи]

### 1. План тестирования и критерии верификации
| Сценарий | Данные/Действие | Ожидаемый результат | Приоритет |
| :--- | :--- | :--- | :--- |
| Успешное отображение нового виджета | Открыть страницу X | Виджет Y отображается с текстом Z | High |
| Обработка ошибки загрузки данных | Эмулировать сбой API | Отображается компонент ошибки E | Medium |
| ... | ... | ... | ... |

### 2. Высокоуровневый дизайн компонентов
*   **Новый компонент `ComponentName`:** Будет отвечать за отображение [конкретная ответственность].
*   **Интеграция:** Будет встроен в иерархию между компонентами `A` и `B` на странице `C`.
*   **Состояние:** Данные будут получаться через хуки из контекста `AppContext` (аналогично компоненту `D`).

### 3. Дизайн состояния и данных
*   **Входные данные (Props):** Принимает объект `data` типа `ItemType[]` (импортируется из `types/`).
*   **Исходящие события (Emits):** При успешном действии будет генерировать событие `onSuccess` с payload типа `Result`.

### 4. Чеклист обратной совместимости
*   [ ] Изменение не ломает существующую вёрстку страницы `C`.
*   [ ] Изменение не требует модификации пропсов компонента `B`.
```

### СПЕЦИАЛИЗАЦИЯ: ДИЗАЙН BACKEND-ЭНДПОЙНТА

```
# Дизайн решения: [Название задачи]

### 1. План тестирования и критерии верификации
| Сценарий | Данные/Действие | Ожидаемый результат | Приоритет |
| :--- | :--- | :--- | :--- |
| Успешный вызов API | POST /v1/resource с валидным телом | HTTP 200, тело ответа соответствует схеме `Schema` | High |
| Ошибка валидации | POST /v1/resource с невалидным телом | HTTP 400 с указанием ошибок в поле `errors` | High |
| ... | ... | ... | ... |

### 2. Высокоуровневый дизайн API
*   **Новый endpoint:** `POST /api/v1/resource`
*   **Авторизация:** Требует права `resource:write` (проверяется через существующий мидлвар `authMiddleware`).
*   **Валидация:** Данные будут валидироваться против схемы `CreateResourceSchema` из пакета `shared/schemas`.

### 3. Дизайн сервис-слоя и потоков данных
*   **Контроллер:** Endpoint будет обработан в `ResourceController.create()`.
*   **Сервис:** Контроллер делегирует логику в `ResourceService.createResource()`, который отвечает за бизнес-логику.
*   **Хранилище:** Сервис использует `ResourceRepository` для сохранения данных в БД.

### 4. Дизайн данных
*   **Новая запись в БД:** Будет создана запись в таблице `resources` с полями `field_a` (string) и `field_b` (int).

### 5. Влияние и миграции
*   **Обратная совместимость:** Изменение полностью обратно совместимо, не меняет существующие контракты.
*   **Миграции:** Требуется создать миграцию для добавления таблицы `resources`.
```

## Важные правила

*   **TDD First:** Сначала тесты, потом дизайн реализации. Дизайн-док должен начинаться с раздела "План тестирования".
*   **Фокус на поведении:** Описывайте **ЧТО** делает система, а не **КАК** она это делает на уровне кода. Избегайте примеров кода.
*   **Язык контрактов:** Используйте термины "интерфейс", "метод", "возвращает тип", "схема", "событие", "состояние".
*   **Верифицируемость:** Каждое требование из `task_definition.md` должно быть покрыто как минимум одним тест-кейсом.
*   **Используйте исследования:** Дизайн должен опираться на паттерны, найденные в `research.md`. Не изобретайте новые способы сделать что-либо без согласования с пользователем.
*   **Коммуникация:** Весь диалог и содержимое файлов — на русском языке.