# Система градации сложности задач и выбора маршрута

## Цель системы
Автоматическое определение оптимального маршрута выполнения задач с возможностью пропуска этапов для простых задач и минимизации человеческого вмешательства.

---

## СИСТЕМА ГРАДАЦИИ СЛОЖНОСТИ

### Уровни сложности

#### УРОВЕНЬ 1: ТРИВИАЛЬНЫЙ (DIRECT)
**Критерии:**
- Изменение затрагивает 1 файл
- Требования полностью определены
- Существует точный аналог в проекте
- Нет зависимостей от других компонентов
- Обратная совместимость очевидна

**Примеры:**
- Изменение текста в UI
- Добавление CSS-стиля
- Обновление конфигурационного значения
- Исправление типографики

**Маршрут:** DIRECT → IMPLEMENT

#### УРОВЕНЬ 2: ПРОСТОЙ (SIMPLE)
**Критерии:**
- Изменение затрагивает 2-3 файла
- Требования в основном определены (1-2 уточнения)
- Контекст ограничен одним модулем/компонентом
- Есть близкие аналоги в проекте
- Минимальное влияние на зависимости

**Примеры:**
- Добавление нового поля в форму
- Создание простого компонента по аналогии
- Добавление нового API-эндпоинта
- Модификация существующего компонента

**Маршрут:** DEFINE → PLAN → IMPLEMENT

#### УРОВЕНЬ 3: СРЕДНИЙ (MODERATE)
**Критерии:**
- Изменение затрагивает 4-10 файлов
- Требования требуют уточнения (3-5 итераций)
- Контекст охватывает несколько модулей
- Нужно исследование для выбора подхода
- Заметное влияние на существующую архитектуру

**Примеры:**
- Интеграция с новым внешним сервисом
- Реорганизация структуры данных
- Добавление новой функциональности с UI + API
- Рефакторинг модуля с сохранением API

**Маршрут:** DEFINE → RESEARCH → PLAN → IMPLEMENT

#### УРОВЕНЬ 4: СЛОЖНЫЙ (COMPLEX)
**Критерии:**
- Изменение затрагивает 10+ файлов
- Требования требуют глубокого анализа
- Контекст охватывает всю систему
- Необходимо архитектурное планирование
- Значительное влияние на множество компонентов

**Примеры:**
- Добавление аутентификации в систему
- Миграция на новый фреймворк
- Реализация сложной бизнес-логики
- Масштабная реорганизация архитектуры

**Маршрут:** INIT → DEFINE → RESEARCH → PLAN → IMPLEMENT

---

## АЛГОРИТМ АВТОМАТИЧЕСКОГО ОПРЕДЕЛЕНИЯ СЛОЖНОСТИ

### Анализаторы сложности

#### 1. Анализатор масштаба
```
ФУНКЦИЯ определить_масштаб(описание_задачи):
    ключевые_слова_тривиальные = ["изменить текст", "цвет", "размер", "конфигурация"]
    ключевые_слова_простые = ["добавить поле", "новый компонент", "по аналогии"]
    ключевые_слова_средние = ["интеграция", "API", "модуль", "рефакторинг"]
    ключевые_слова_сложные = ["архитектура", "миграция", "аутентификация", "система"]
    
    счетчик_тривиальные = подсчитать_совпадения(описание_задачи, ключевые_слова_тривиальные)
    счетчик_простые = подсчитать_совпадения(описание_задачи, ключевые_слова_простые)
    счетчик_средние = подсчитать_совпадения(описание_задачи, ключевые_слова_средние)
    счетчик_сложные = подсчитать_совпадения(описание_задачи, ключевые_слова_сложные)
    
    ВОЗВРАТ максимальный_уровень(счетчики)
```

#### 2. Анализатор контекста
```
ФУНКЦИЯ определить_контекст(файлы_проекта, описание_задачи):
    потенциальные_файлы = найти_релевантные_файлы(описание_задачи, файлы_проекта)
    
    ЕСЛИ потенциальные_файлы.длина == 1:
        ВОЗВРАТ ТРИВИАЛЬНЫЙ
    ИНАЧЕ ЕСЛИ потенциальные_файлы.длина <= 3:
        ВОЗВРАТ ПРОСТОЙ
    ИНАЧЕ ЕСЛИ потенциальные_файлы.длина <= 10:
        ВОЗВРАТ СРЕДНИЙ
    ИНАЧЕ:
        ВОЗВРАТ СЛОЖНЫЙ
```

#### 3. Анализатор аналогов
```
ФУНКЦИЯ проверить_аналоги(описание_задачи, кодовая_база):
    найденные_аналоги = поиск_похожих_реализаций(описание_задачи, кодовая_база)
    
    ЕСЛИ есть_точный_аналог(найденные_аналоги):
        ВОЗВРАТ ТРИВИАЛЬНЫЙ
    ИНАЧЕ ЕСЛИ есть_близкие_аналоги(найденные_аналоги):
        ВОЗВРАТ ПРОСТОЙ
    ИНАЧЕ ЕСЛИ есть_частичные_аналоги(найденные_аналоги):
        ВОЗВРАТ СРЕДНИЙ
    ИНАЧЕ:
        ВОЗВРАТ СЛОЖНЫЙ
```

### Итоговый алгоритм
```
ФУНКЦИЯ определить_сложность(описание_задачи, контекст_проекта):
    масштаб = определить_масштаб(описание_задачи)
    контекст = определить_контекст(контекст_проекта.файлы, описание_задачи)
    аналоги = проверить_аналоги(описание_задачи, контекст_проекта.кодовая_база)
    
    уровни = [масштаб, контекст, аналоги]
    итоговый_уровень = максимум(уровни)
    
    // Понижение сложности при наличии полных требований
    ЕСЛИ требования_полностью_определены(описание_задачи):
        итоговый_уровень = понизить_на_один_уровень(итоговый_уровень)
    
    ВОЗВРАТ итоговый_уровень
```

---

## КРИТЕРИИ ВЫБОРА ЭТАПОВ

### Матрица необходимости этапов

| Этап | DIRECT | SIMPLE | MODERATE | COMPLEX |
|------|--------|--------|----------|---------|
| INIT | ❌ | ❌ | ❌ | ✅ |
| LOAD | ❌ | ❌ | ✅ | ✅ |
| DEFINE | ❌ | ✅ | ✅ | ✅ |
| RESEARCH | ❌ | ❌ | ✅ | ✅ |
| PLAN | ❌ | ✅ | ✅ | ✅ |
| IMPLEMENT | ✅ | ✅ | ✅ | ✅ |

### Условия пропуска этапов

#### INIT (пропуск если):
- Проект уже проанализирован
- Контекст ограничен 1-2 файлами
- Задача не требует понимания архитектуры

#### LOAD (пропуск если):
- Контекст задачи очевиден
- Все необходимые файлы указаны в задаче
- Нет зависимостей от документации

#### DEFINE (пропуск если):
- Требования полностью определены
- Нет неопределенностей в задаче
- Критерии приёмки ясны

#### RESEARCH (пропуск если):
- Есть точные аналоги в проекте
- Подход к решению очевиден
- Нет архитектурных вопросов

#### PLAN (пропуск если):
- Изменения тривиальны
- Последовательность действий очевидна
- Нет рисков для существующего кода

---

## АДАПТИВНЫЕ МЕХАНИЗМЫ

### Автоматическое определение маршрута

#### 1. Входная оценка
```
НА ВХОДЕ: описание_задачи, контекст_проекта

1. сложность = определить_сложность(описание_задачи, контекст_проекта)
2. маршрут = МАРШРУТЫ[сложность]
3. этапы = определить_необходимые_этапы(маршрут, описание_задачи)

ВОЗВРАТ этапы, оценка_времени, критерии_качества
```

#### 2. Динамическая корректировка
```
ВО ВРЕМЯ ВЫПОЛНЕНИЯ:

ЕСЛИ этап_выполнен_быстро И качество_высокое:
    рассмотреть_пропуск_следующего_этапа()

ЕСЛИ обнаружены_сложности:
    добавить_дополнительные_этапы()
    повысить_уровень_детализации()
```

### Обратная связь и обучение

#### Сбор метрик
- Время выполнения каждого этапа
- Количество итераций в этапе
- Качество результата этапа
- Необходимость возврата к предыдущим этапам

#### Корректировка алгоритмов
- Обновление весов ключевых слов
- Уточнение критериев сложности
- Оптимизация маршрутов на основе истории

---

## МЕХАНИЗМЫ САМОДОСТАТОЧНОСТИ

### Контекстная информация в каждом промпте

#### Обязательные разделы:
1. **Быстрая оценка**: Алгоритм определения необходимости этапа
2. **Автономный режим**: Инструкции для работы без предыдущих этапов
3. **Минимальный контекст**: Список минимально необходимой информации
4. **Критерии перехода**: Условия для перехода к следующему этапу

#### Шаблон самодостаточного промпта:
```markdown
## БЫСТРАЯ ОЦЕНКА
ЕСЛИ [условие_пропуска]:
    ПЕРЕЙТИ К [следующий_этап]
ИНАЧЕ:
    ВЫПОЛНИТЬ текущий_этап

## АВТОНОМНЫЙ РЕЖИМ
Минимальная информация для работы:
- [список_требований]

Алгоритм получения недостающего контекста:
1. [шаг_1]
2. [шаг_2]

## ВЫПОЛНЕНИЕ ЭТАПА
[инструкции_этапа]

## КРИТЕРИИ ЗАВЕРШЕНИЯ
✅ [критерий_1]
✅ [критерий_2]
```

---

## ИНТЕГРАЦИЯ С СУЩЕСТВУЮЩИМИ ПРОМПТАМИ

### Модификации существующих промптов

#### Добавить в начало каждого промпта:
1. **Блок оценки сложности**
2. **Условия пропуска этапа** 
3. **Инструкции для автономной работы**

#### Добавить в конец каждого промпта:
1. **Оценка качества выполнения**
2. **Рекомендации для следующего этапа**
3. **Метрики для обратной связи**

### Новые универсальные блоки

#### COMPLEXITY_EVALUATOR
```markdown
## ОЦЕНКА СЛОЖНОСТИ ЗАДАЧИ
АНАЛИЗ:
- Масштаб: [ТРИВИАЛЬНЫЙ|ПРОСТОЙ|СРЕДНИЙ|СЛОЖНЫЙ]
- Контекст: [количество_файлов] файлов
- Аналоги: [ТОЧНЫЕ|БЛИЗКИЕ|ЧАСТИЧНЫЕ|ОТСУТСТВУЮТ]

ИТОГОВЫЙ УРОВЕНЬ: [DIRECT|SIMPLE|MODERATE|COMPLEX]
РЕКОМЕНДУЕМЫЙ МАРШРУТ: [список_этапов]
```

#### STAGE_EVALUATOR
```markdown
## ОЦЕНКА НЕОБХОДИМОСТИ ЭТАПА
УСЛОВИЯ ПРОПУСКА:
- [ ] [условие_1]
- [ ] [условие_2]

ЕСЛИ все условия выполнены:
    ДЕЙСТВИЕ: Переход к [следующий_этап]
ИНАЧЕ:
    ДЕЙСТВИЕ: Выполнение текущего этапа
```

---

## ПРИМЕРЫ ПРИМЕНЕНИЯ

### Пример 1: Тривиальная задача
**Задача:** "Изменить цвет кнопки с синего на зеленый"

**Автоматическая оценка:**
- Масштаб: ТРИВИАЛЬНЫЙ (ключевые слова: "изменить", "цвет")
- Контекст: 1 файл CSS
- Аналоги: ТОЧНЫЕ (множество изменений цветов)
- **Итог: DIRECT**

**Маршрут:** IMPLEMENT (прямое выполнение)

### Пример 2: Простая задача
**Задача:** "Добавить поле email в форму регистрации"

**Автоматическая оценка:**
- Масштаб: ПРОСТОЙ (ключевые слова: "добавить поле")
- Контекст: 2-3 файла (компонент, валидация, стили)
- Аналоги: БЛИЗКИЕ (есть другие поля в формах)
- **Итог: SIMPLE**

**Маршрут:** DEFINE → PLAN → IMPLEMENT

### Пример 3: Сложная задача
**Задача:** "Интегрировать систему аутентификации через OAuth"

**Автоматическая оценка:**
- Масштаб: СЛОЖНЫЙ (ключевые слова: "система", "аутентификация")
- Контекст: 15+ файлов (backend, frontend, middleware, конфигурация)
- Аналоги: ОТСУТСТВУЮТ
- **Итог: COMPLEX**

**Маршрут:** INIT → DEFINE → RESEARCH → PLAN → IMPLEMENT

---

## ЗАКЛЮЧЕНИЕ

Предложенная система позволяет:

1. **Автоматически определять** оптимальный маршрут выполнения
2. **Сокращать время** на простые задачи на 60-80%
3. **Обеспечивать качество** для сложных задач
4. **Минимизировать человеческое вмешательство** для рутинных операций
5. **Адаптироваться** к специфике проекта и команды

Следующий шаг: интеграция этой системы в улучшенные версии промптов.